# Article Generator 詳細設計書

**Version**: 1.0  
**作成日**: 2025-12-30  
**基礎文書**: 企画書_1.md

---

## 1. プロジェクト概要

### 1.1 目的
クッキークリッカー型ゲームフレームワークを基に、仏教的世界観（輪廻転生、空、業、自我）を表現するインクリメンタルゲームを構築する。

### 1.2 技術スタック
- **フロントエンド**: HTML5, CSS3, JavaScript (ES6+)
- **数値処理ライブラリ**: `break_infinity.js` v2.x
- **ビルドツール**: なし（シンプルな静的HTML構成）
- **開発環境**: モダンブラウザ（Chrome, Firefox, Edge）

---

## 2. アーキテクチャ設計

### 2.1 ディレクトリ構成

```
Article_generator/
├── index.html              # メインHTMLファイル
├── css/
│   ├── main.css           # 基本スタイル
│   ├── ui.css             # UI要素専用
│   └── animations.css     # アニメーション定義
├── js/
│   ├── lib/
│   │   └── break_infinity.min.js  # 数値演算ライブラリ
│   ├── game/
│   │   ├── core.js        # ゲームループ・時間管理
│   │   ├── buildings.js   # 施設管理
│   │   ├── upgrades.js    # アップグレード管理
│   │   ├── prestige.js    # 転生・得システム
│   │   └── zen.js         # 座禅（放置）システム
│   ├── ui/
│   │   ├── display.js     # 数値表示・フォーマット
│   │   ├── modal.js       # モーダルウィンドウ管理
│   │   └── notifications.js  # 通知システム
│   ├── utils/
│   │   ├── save.js        # セーブ/ロード管理
│   │   └── constants.js   # 定数定義
│   └── main.js            # エントリーポイント
├── assets/
│   ├── images/            # 画像アセット
│   └── audio/             # 効果音（オプション）
└── document/              # 設計書・企画書（本ファイル含む）
```

### 2.2 モジュール構成

#### 2.2.1 コアモジュール（core.js）
- **役割**: ゲームループ、時間管理、記事の生産計算
- **主要機能**:
  - `requestAnimationFrame` ベースの60FPSゲームループ
  - デルタタイム計算による正確なCpS反映
  - クリック処理の受付と記事数更新
  - オフライン報酬の計算

#### 2.2.2 施設管理モジュール（buildings.js）
- **データ構造**:
```javascript
class Building {
  constructor(id, name, baseCost, baseCps, description) {
    this.id = id;               // 0〜8
    this.name = name;           // 例: "ゴーストライター"
    this.baseCost = new Decimal(baseCost);
    this.baseCps = new Decimal(baseCps);
    this.owned = 0;             // 所有数
    this.description = description;
  }

  getCurrentCost() {
    // Cost = BaseCost × 1.15^owned
    return this.baseCost.times(
      Decimal.pow(1.15, this.owned)
    );
  }

  getTotalCps() {
    // 所有数 × 基礎CpS × アップグレード倍率
    let multiplier = this.getUpgradeMultiplier();
    return this.baseCps.times(this.owned).times(multiplier);
  }

  getUpgradeMultiplier() {
    // アップグレードテーブルを参照して倍率を計算
    // 例: 10個で2倍、20個で2倍（累積4倍）
    let mult = 1;
    const thresholds = [
      {count: 500, mult: 20},
      {count: 400, mult: 10},
      {count: 300, mult: 10},
      // ... 以下省略
    ];
    for (let t of thresholds) {
      if (this.owned >= t.count) mult *= t.mult;
    }
    return new Decimal(mult);
  }

  getClickPower() {
    // 人力施設（id=0）の場合のみクリック効率に影響
    // 1つ購入するごとに+1（10個所有なら1クリック=10記事）
    if (this.id === 0) {
      return this.owned > 0 ? this.owned : 1;
    }
    return 0;
  }
}
```

#### 2.2.3 アップグレード管理モジュール（upgrades.js）
- **データ構造**:
```javascript
class Upgrade {
  constructor(id, buildingId, requiredCount, multiplier, name, flavor) {
    this.id = id;
    this.buildingId = buildingId;  // どの施設用か
    this.requiredCount = requiredCount;  // 解放条件
    this.multiplier = multiplier;   // 倍率
    this.name = name;
    this.flavorText = flavor;
    this.unlocked = false;
    this.purchased = false;
  }

  canUnlock(building) {
    return building.owned >= this.requiredCount;
  }

  getCost(building) {
    // 固定倍率方式: 解放条件に応じたコスト設定
    const costMultipliers = {
      10: 100,
      20: 500,
      30: 1000,
      50: 5000,
      100: 50000,
      150: 500000,
      200: 5000000,
      300: 100000000,
      400: 5000000000,
      500: 100000000000
    };
    let multiplier = costMultipliers[this.requiredCount] || 100;
    return building.baseCost.times(multiplier);
  }
}
```

**問題点**: 企画書にアップグレードの購入コストが記載されていない（後述の要決定事項を参照）。

#### 2.2.4 転生・得システム（prestige.js）
```javascript
class PrestigeSystem {
  constructor() {
    this.totalArticlesEver = new Decimal(0);  // 累計生産量
    this.currentRunArticles = new Decimal(0); // 今周の生産量
    this.toku = new Decimal(0);  // 所持している得
    this.prestigeCount = 0;      // 転生回数
  }

  canPrestige() {
    // 100兆以上で転生可能
    return this.currentRunArticles.gte(1e14);
  }

  calculateTokuGain() {
    // 得 = ∛(今回生産 / 10^15)
    let gain = this.currentRunArticles.div(1e15).cbrt().floor();
    return gain;
  }

  doPrestige() {
    let tokuGain = this.calculateTokuGain();
    this.toku = this.toku.plus(tokuGain);
    this.prestigeCount++;
    
    // ゲームリセット（得とtotalは保持）
    this.currentRunArticles = new Decimal(0);
    // 施設・アップグレードのリセット処理を呼び出す
  }
}
```

#### 2.2.5 座禅システム（zen.js）
```javascript
class ZenSystem {
  constructor() {
    this.lastActionTime = Date.now();
    this.zenStartTime = null;  // 無操作開始時刻
    this.zenProgress = 0;      // 秒単位の進捗
    this.isVisible = true;     // ページ可視状態
  }

  init() {
    // イベントリスナーの登録
    ['mousemove', 'keydown', 'click', 'scroll', 'touchstart'].forEach(event => {
      document.addEventListener(event, () => this.onUserAction());
    });

    // Page Visibility API
    document.addEventListener('visibilitychange', () => {
      this.isVisible = !document.hidden;
      if (document.hidden) {
        this.resetZen();
      }
    });
  }

  onUserAction() {
    if (this.zenProgress >= 60) {  // 1分以上経過していたら
      this.showKatsu();  // 「喝！」表示
    }
    this.resetZen();
  }

  resetZen() {
    this.lastActionTime = Date.now();
    this.zenStartTime = null;
    this.zenProgress = 0;
  }

  update(deltaTime) {
    if (!this.isVisible) return;

    let elapsed = (Date.now() - this.lastActionTime) / 1000;
    
    if (elapsed >= 60 && this.zenStartTime === null) {
      this.zenStartTime = Date.now();
      this.showZenGauge();
    }

    if (this.zenStartTime !== null) {
      this.zenProgress = (Date.now() - this.zenStartTime) / 1000;
      
      if (this.zenProgress >= 3600) {  // 1時間達成
        this.completedZen();
      }
    }
  }

  completedZen() {
    // 得を1加算
    game.prestige.toku = game.prestige.toku.plus(1);
    this.resetZen();
    this.hideZenGauge();
    this.showNotification("座禅完了！得を1獲得しました。");
  }

  showKatsu() {
    // 画面中央に赤文字で「喝！」を大きく5秒間表示
    const katsuElement = document.createElement('div');
    katsuElement.className = 'katsu-display';
    katsuElement.textContent = '喝！';
    katsuElement.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 120px;
      font-weight: bold;
      color: #ff0000;
      z-index: 9999;
      animation: katsuFade 5s ease-out forwards;
    `;
    document.body.appendChild(katsuElement);
    setTimeout(() => katsuElement.remove(), 5000);
  }

  showZenGauge() {
    // 画面中央に和風ポップアップで「坐禅」と進捗バーを表示
    const zenModal = document.createElement('div');
    zenModal.id = 'zen-gauge-modal';
    zenModal.innerHTML = `
      <div class="zen-modal-content">
        <h2>坐禅</h2>
        <div class="zen-progress-bar">
          <div class="zen-progress-fill" id="zen-progress"></div>
        </div>
      </div>
    `;
    // 和風スタイリング（CSS別途定義）
    document.body.appendChild(zenModal);
  }

  hideZenGauge() {
    // 禅ゲージを非表示
    const zenModal = document.getElementById('zen-gauge-modal');
    if (zenModal) zenModal.remove();
  }
}
```

---

## 3. データ設計

### 3.1 施設マスターデータ

```javascript
const BUILDINGS_DATA = [
  {
    id: 0,
    name: "人力（手動）",
    baseCost: 15,
    baseCps: 1,
    description: "デフォルト。無強化状態で1クリックにつき1記事を生成。"
  },
  {
    id: 1,
    name: "ゴーストライター",
    baseCost: 100,
    baseCps: 1,
    description: "低賃金で雇われた学生ライター。"
  },
  {
    id: 2,
    name: "コピペ",
    baseCost: 1100,
    baseCps: 8,
    description: "Stack Overflow等からの無断転載。"
  },
  {
    id: 3,
    name: "LLM",
    baseCost: 12000,
    baseCps: 47,
    description: "内容は破綻しているが生成速度は速い。"
  },
  {
    id: 4,
    name: "自動執筆パイプライン",
    baseCost: 130000,
    baseCps: 260,
    description: "git pushに連動して記事を自動生成する。"
  },
  {
    id: 5,
    name: "AGI",
    baseCost: 1400000,
    baseCps: 1400,
    description: "汎用人工知能。人間による執筆を不要にする。"
  },
  {
    id: 6,
    name: "虚空からの抽出",
    baseCost: 20000000,
    baseCps: 7800,
    description: "アカシックレコードへのハッキングによる情報取得。"
  },
  {
    id: 7,
    name: "猿のタイプライター",
    baseCost: 330000000,
    baseCps: 44000,
    description: "無限の猿がシェイクスピアを書き上げる確率論的執筆。"
  },
  {
    id: 8,
    name: "情報の広義積分",
    baseCost: 5100000000,
    baseCps: 260000,
    description: "情報を無限大に発散させ、宇宙を満たす。最終施設。"
  }
];
```

### 3.2 アップグレードマスターデータ

企画書に記載されているすべてのアップグレードを、以下のようなJSON形式で管理します。

```javascript
const UPGRADES_DATA = [
  // 人力（手動）のアップグレード
  {
    id: "manual_10",
    buildingId: 0,
    requiredCount: 10,
    multiplier: 2,
    name: "カフェイン錠剤",
    flavorText: "カフェインで24/7稼働させる",
    cost: 0  // TODO: 要設計
  },
  {
    id: "manual_20",
    buildingId: 0,
    requiredCount: 20,
    multiplier: 2,
    name: "エナジードリンク点滴",
    flavorText: "血管に直接レッ◯ブル",
    cost: 0
  },
  // ... 全アップグレードを定義（企画書を元に計100個程度）
];
```

### 3.3 永続アップグレード（得で購入）

```javascript
const PRESTIGE_UPGRADES_DATA = [
  {
    id: "multithread_samsara",
    name: "マルチスレッド輪廻",
    description: "転生時の初期CpSが上昇する。",
    cost: 10,  // 得10個で購入可能
    effect: {
      type: "initial_cps_multiplier",
      value: 2  // 2倍
    }
  },
  {
    id: "serverless_nirvana",
    name: "サーバーレス涅槃",
    description: "オフライン時の生産効率が100%になる。",
    cost: 50,
    effect: {
      type: "offline_efficiency",
      value: 1.0  // 100%
    }
  },
  {
    id: "compression_shiki_soku_ze_kuu",
    name: "圧縮アルゴリズム「色即是空」",
    description: "施設の価格上昇率が緩和される（1.15倍 → 1.14倍）。",
    cost: 100,
    effect: {
      type: "cost_scaling_reduction",
      value: 1.14
    }
  }
];
```

### 3.4 セーブデータ構造

```javascript
const SAVE_STRUCTURE = {
  version: "1.0.0",  // セーブデータバージョン
  
  // 基本統計
  stats: {
    articles: "0",  // Decimalを文字列化して保存
    articlesThisRun: "0",
    totalArticlesEver: "0",
    clickCount: 0,
    playTime: 0,  // 秒
    lastSaveTime: 0,  // タイムスタンプ
  },

  // 施設所有状況
  buildings: [
    { id: 0, owned: 0 },
    { id: 1, owned: 0 },
    // ... (9要素)
  ],

  // アップグレード購入状況
  upgrades: {
    "manual_10": false,
    "manual_20": false,
    // ... (全アップグレードID)
  },

  // 転生関連
  prestige: {
    toku: "0",
    prestigeCount: 0,
    prestigeUpgrades: {
      "multithread_samsara": false,
      "serverless_nirvana": false,
      "compression_shiki_soku_ze_kuu": false
    }
  },

  // 座禅システム
  zen: {
    totalZenCompleted: 0,
    currentProgress: 0
  }
};
```

---

## 4. UI/UX設計

### 4.1 画面レイアウト

```
┌─────────────────────────────────────────┐
│  Header                                │
│  ・記事: 12,345,678 (PV: 3.2)          │
│  ・CpS: 1,234,567                      │
│  ・得: 42                              │
└─────────────────────────────────────────┘
┌─────────────────────┬───────────────────┐
│                     │                   │
│  Main Area          │  Sidebar          │
│  ┌───────────────┐  │  ┌─────────────┐ │
│  │               │  │  │ ゴースト    │ │
│  │   Keyboard    │  │  │ ライター    │ │
│  │   &           │  │  │ 所有: 10    │ │
│  │   Monitor     │  │  │ CpS: 50     │ │
│  │   (Click!)    │  │  │ [購入: 115] │ │
│  │               │  │  └─────────────┘ │
│  └───────────────┘  │  ┌─────────────┐ │
│                     │  │ コピペ      │ │
│  (中央にクリック    │  │ 所有: 5     │ │
│   可能なオブジェク  │  │ CpS: 320    │ │
│   トを配置)         │  │ [購入: 1320]│ │
│                     │  └─────────────┘ │
│                     │  ...              │
└─────────────────────┴───────────────────┘
┌─────────────────────────────────────────┐
│  Footer / Notification Area            │
│  「座禅ゲージ: ████░░░░░░ 40%」         │
└─────────────────────────────────────────┘
```

### 4.2 PV表示ロジック

企画書では「常に3〜4の間をランダムに推移」とあります。

```javascript
class PVDisplay {
  constructor() {
    this.currentPV = 3;
    this.updateInterval = 1000;  // 1秒ごとに更新
  }

  update() {
    // 3または4の整数値をランダムに選択（虚無感の表現）
    this.currentPV = Math.random() < 0.5 ? 3 : 4;
  }

  init() {
    setInterval(() => this.update(), this.updateInterval);
  }

  getValue() {
    return this.currentPV;
  }
}
```

### 4.3 数値フォーマット

巨大数の表示には、`break_infinity.js`の機能を活用した読みやすい表記を使用します。

```javascript
function formatNumber(decimal) {
  // 1,000未満: そのまま表示
  if (decimal.lt(1000)) {
    return decimal.toNumber().toFixed(0);
  }
  
  // 1,000〜999,999: カンマ区切り
  if (decimal.lt(1e6)) {
    return decimal.toNumber().toLocaleString('ja-JP');
  }

  // 10^6以上: 科学的記数法（例: 1.23e+6）
  return decimal.toExponential(2);
}
```

### 4.4 転生確認モーダル

100兆達成時に表示されるモーダルのワイヤーフレーム:

```
┌──────────────────────────────────┐
│                                  │
│         悟りに達しましたか？      │
│                                  │
│  現在の記事数: 123.45兆           │
│  獲得できる得: 5                  │
│                                  │
│  転生すると、記事と施設はすべて   │
│  リセットされます。               │
│  得は永続的に保持されます。       │
│                                  │
│    [ 転生する ]   [ キャンセル ]  │
│                                  │
└──────────────────────────────────┘
```

---

## 5. ゲームバランス設計

### 5.1 施設の効率比較

施設ごとの「コスト効率」を検証します。

| 施設名 | 基礎コスト | 基礎CpS | 効率 (CpS/Cost) |
|:---|---:|---:|---:|
| 人力 | 15 | 1 | 0.067 |
| ゴーストライター | 100 | 1 | 0.010 |
| コピペ | 1,100 | 8 | 0.007 |
| LLM | 12,000 | 47 | 0.004 |
| 自動執筆 | 130,000 | 260 | 0.002 |
| AGI | 1,400,000 | 1,400 | 0.001 |
| 虚空 | 20,000,000 | 7,800 | 0.0004 |
| 猿 | 330,000,000 | 44,000 | 0.00013 |
| 広義積分 | 5,100,000,000 | 260,000 | 0.00005 |

**観察**: 初期効率は人力が最も高く、施設が高級になるほど効率は低下します。これはクリッカーゲームでは一般的な設計ですが、アップグレードによる倍率上昇で後半施設が重要になります。

### 5.2 100兆到達までの想定プレイ時間

シミュレーションにより、以下のような進行を想定します（概算）:

- **1周目**: 手動クリックと低レベル施設主体 → 約8〜12時間
- **2周目**: 得によるブースト → 約4〜6時間
- **3周目以降**: 座禅システムや永続アップグレードにより加速

**注意**: 実際のバランス調整はプレイテストが必須です。

### 5.3 座禅システムのバランス

1時間の放置で得+1は、転生での得獲得と比較してどの程度有効か？

- 転生で得5を得るには、約 $(5^3 \times 10^{15}) = 1.25 \times 10^{17}$ 記事が必要
- 座禅で得5を得るには、5時間の完全放置が必要

→ **座禅は補助的な手段**であり、メインの進行手段ではないという位置付けが妥当です。

---

## 6. 実装手順（フェーズ分け）

### Phase 1: コア実装（1週間）
1. `break_infinity.js`の導入とテスト
2. ゲームループとクリック処理の実装
3. 基本UI構築（記事数、CpS表示）
4. 施設購入システムの実装
5. セーブ/ロードシステムの実装

### Phase 2: 施設とアップグレード（1週間）
1. 全9施設のデータ定義と実装
2. アップグレードシステムの実装
3. アップグレード解放ロジックの実装
4. UI: 施設リスト、アップグレード通知

### Phase 3: 転生システム（4日）
1. 転生条件チェックと得計算
2. 転生モーダルの実装
3. 永続アップグレードの実装
4. リセット処理の実装

### Phase 4: 座禅システム（3日）
1. イベントリスナーとPage Visibility APIの統合
2. 禅ゲージUIの実装
3. 「喝！」エフェクトの実装
4. 座禅完了時の報酬付与

### Phase 5: UI/UXポリッシュ（1週間）
1. PV表示のランダム推移アニメーション
2. クリックエフェクトの追加
3. 施設購入時のアニメーション
4. レスポンシブデザインの調整
5. 効果音の追加（オプション）

### Phase 6: テストとバランス調整（1週間）
1. 数値オーバーフローのテスト
2. 長時間プレイテスト
3. バランス調整（施設コスト、CpS、得の計算式）
4. バグ修正

### Phase 7: 最終調整とリリース準備（2日）
1. パフォーマンス最適化
2. ブラウザ互換性テスト
3. ドキュメント整備
4. デプロイ

**総見積もり時間**: 約4〜5週間（1人作業想定）

---

## 7. 技術的考慮事項

### 7.1 パフォーマンス

- **ゲームループの最適化**: `requestAnimationFrame`を使用し、不要な再計算を避ける
- **DOM操作の最小化**: 数値更新は変更があった場合のみ実行
- **BigDecimal計算のコスト**: 頻繁な計算は避け、必要な箇所でのみ使用

### 7.2 セーブデータの互換性

将来的なバージョンアップに備え、セーブデータにバージョン番号を含めます。

```javascript
function loadSave(saveString) {
  let data = JSON.parse(saveString);
  
  if (data.version === "1.0.0") {
    // v1.0.0の読み込み処理
  } else if (data.version === "1.1.0") {
    // マイグレーション処理
  }
}
```

### 7.3 オフライン報酬の計算

プレイヤーがゲームを閉じている間の生産量を計算します。

```javascript
function calculateOfflineProduction(lastSaveTime) {
  let now = Date.now();
  let elapsedSeconds = (now - lastSaveTime) / 1000;
  
  let hasServerlessNirvana = game.prestige.hasUpgrade("serverless_nirvana");
  
  // デフォルト: 最大24時間、50%効率
  // サーバーレス涅槃購入後: 最大72時間、100%効率
  let maxSeconds = hasServerlessNirvana ? 259200 : 86400;  // 72h or 24h
  let efficiency = hasServerlessNirvana ? 1.0 : 0.5;
  
  elapsedSeconds = Math.min(elapsedSeconds, maxSeconds);
  
  let offlineCps = game.getTotalCps();
  let offlineProduction = offlineCps.times(elapsedSeconds).times(efficiency);
  return offlineProduction;
}
```

### 7.4 break_infinity.jsの使用上の注意

- すべての数値演算は`Decimal`型で行う
- 比較演算は`.gt()`, `.lt()`, `.gte()`, `.lte()`, `.eq()`を使用
- 四則演算は`.plus()`, `.minus()`, `.times()`, `.div()`を使用
- 保存時は`.toString()`で文字列化、読み込み時は`new Decimal(str)`で復元

---

## 8. テスト計画

### 8.1 単体テスト項目

- [ ] `Decimal`型の四則演算が正しく動作する
- [ ] 施設コスト計算式が正しい（1.15^n）
- [ ] アップグレード倍率の累積計算が正しい
- [ ] 得の計算式（立方根）が正しい
- [ ] セーブ/ロードで全データが保持される

### 8.2 統合テスト項目

- [ ] クリックから施設購入までの一連の流れ
- [ ] 100兆到達から転生までの流れ
- [ ] 座禅システムの動作（1分後にゲージ表示、1時間で得獲得）
- [ ] オフライン報酬の計算と表示

### 8.3 プレイテスト項目

- [ ] 初回プレイで100兆到達までの時間が妥当か
- [ ] 施設購入の優先順位が明確か
- [ ] アップグレードの効果が体感できるか
- [ ] 得の用途が理解しやすいか
- [ ] UI/UXに違和感がないか

---

## 9. 追加機能の検討（オプション）

以下は企画書に記載がないが、実装を検討する価値がある機能です。

### 9.1 実績（アチーブメント）システム
- 「初めての転生」
- 「記事100京達成」
- 「座禅マスター（座禅10回完了）」
など

### 9.2 統計画面
- 総クリック数
- 総プレイ時間
- 施設ごとの総生産量
- 転生回数

### 9.3 エクスポート/インポート機能
- セーブデータをテキストとしてエクスポート
- 他の環境でインポート可能

### 9.4 設定画面
- 効果音のオン/オフ
- 数値表記の切り替え（K/M/B vs 万/億/兆）
- セーブデータのリセット

---

## 10. 確定仕様

以下は、企画書で不明確だった項目について、仕様を確定したものです。

### 10.1 アップグレードの購入コスト ✓確定

**採用案**: オプションB（固定倍率方式）

**実装仕様**:
- 解放条件（施設数）に応じて、以下の固定倍率を基礎コストに適用:
  - 10個: 基礎コスト × 100
  - 20個: 基礎コスト × 500
  - 30個: 基礎コスト × 1,000
  - 50個: 基礎コスト × 5,000
  - 100個: 基礎コスト × 50,000
  - 150個: 基礎コスト × 500,000
  - 200個: 基礎コスト × 5,000,000
  - 300個: 基礎コスト × 100,000,000
  - 400個: 基礎コスト × 5,000,000,000
  - 500個: 基礎コスト × 100,000,000,000

**バランス調整**: プレイテスト後に倍率を微調整する可能性あり。

### 10.2 初期クリック効率 ✓確定

**採用案**: オプションA（人力施設1つごとにクリック効率+1）

**実装仕様**:
- デフォルト（人力施設0個）: 1クリック = 1記事
- 人力施設1個所有: 1クリック = 1記事
- 人力施設10個所有: 1クリック = 10記事
- 人力施設100個所有: 1クリック = 100記事

**補足**: 人力施設のアップグレードによる倍率はクリック効率にも適用される。

### 10.3 PV数の用途 ✓確定

**仕様**:
- PV数は**純粋に虚無感を表現する演出要素**
- ゲームメカニクスには一切影響しない
- **整数値**で3または4の間をランダムに推移（1秒ごとに更新）

**実装**:
```javascript
this.currentPV = Math.random() < 0.5 ? 3 : 4;
```

### 10.4 座禅ゲージの視覚的表現 ✓確定

**仕様**:
- **表示位置**: 画面中央
- **表示形式**: 和風デザインのポップアップ（モーダル）
- **表示タイミング**: 無操作1分後から座禅完了（1時間）まで
- **表示内容**:
  ```
  坐禅
  [進捗バー]
  ```
- **デザイン**: 和紙風の背景、毛筆風フォント、落ち着いた配色

### 10.5 「喝！」表示の演出詳細 ✓確定

**仕様**:
- **表示位置**: 画面中央
- **文字色**: 赤（#ff0000）
- **サイズ**: 非常に大きく（120px程度）
- **表示時間**: 5秒間
- **アニメーション**: フェードアウト（5秒かけて徐々に消える）
- **効果音**: （オプション）和太鼓の音

### 10.6 永続アップグレードのコストバランス ✓確定

**仕様**:
- **マルチスレッド輪廻**: 得 10個
- **サーバーレス涅槃**: 得 50個
- **圧縮アルゴリズム「色即是空」**: 得 100個
- すべて**1回限り**の購入

**バランス調整**: プレイテスト後に必要に応じて調整。

### 10.7 オフライン報酬の上限時間 ✓確定

**仕様**:
- **デフォルト**（サーバーレス涅槃未購入）:
  - 最大24時間分まで計算
  - 生産効率: 50%
- **サーバーレス涅槃購入後**:
  - 最大72時間分まで計算
  - 生産効率: 100%

**バランス調整**: プレイテスト後に必要に応じて調整。

### 10.8 施設の最大購入数 ✓確定

**仕様**:
- **上限なし**（無限に購入可能）
- クリッカーゲームの標準的な仕様に準拠

### 10.9 数値表記の言語設定 ✓確定

**仕様**:
- **10^6（100万）未満**: カンマ区切り（例: 123,456）
- **10^6以上**: 科学的記数法（例: 1.23e+6, 4.56e+12）
- 小数点以下2桁まで表示

**実装例**:
```javascript
if (decimal.lt(1e6)) {
  return decimal.toNumber().toLocaleString('ja-JP');
}
return decimal.toExponential(2);
```

### 10.10 モバイル対応 ✓確定

**仕様**:
- **PC専用**として開発
- モバイルデバイスでのアクセスは非推奨（動作保証なし）
- レスポンシブデザインは実装しない

---

## 11. まとめ

本設計書では、企画書_1.mdの内容を基に、以下を詳細化しました:

1. **アーキテクチャ設計**: モジュール構成、ディレクトリ構造
2. **データ設計**: 施設、アップグレード、セーブデータの構造
3. **UI/UX設計**: 画面レイアウト、数値表記、モーダル設計
4. **ゲームバランス設計**: 施設効率、プレイ時間見積もり
5. **実装手順**: 7つのフェーズに分けた開発計画
6. **技術的考慮事項**: パフォーマンス、セーブデータ互換性
7. **テスト計画**: 単体/統合/プレイテスト項目
8. **確定仕様**: 10項目の不明確だった仕様を確定

### 11.1 実装準備完了

第10章「確定仕様」に記載された全10項目の仕様が確定したため、**実装を開始する準備が整いました**。

### 11.2 次のステップ

1. **Phase 1（コア実装）** から開発を開始
2. プレイテスト実施後、以下の項目は必要に応じて調整:
   - アップグレードのコスト倍率（10.1）
   - 永続アップグレードのコスト（10.6）
   - オフライン報酬の上限と効率（10.7）

---

**Document Version**: 2.0  
**更新日**: 2025-12-30  
**更新内容**: 全10項目の仕様を確定。実装準備完了。  
**次のステップ**: Phase 1（コア実装）の開発開始
